//二分查找
//https://leetcode.cn/problems/binary-search/
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len - 1; //注意不是len/2，也不是len，而是len-1
        if (target < nums[0] | target > nums[len-1]){
            return -1;
        }//可以直接判断的情况
        while(left <= right){
            int middle = left + (right - left) / 2;//相比(left+right)/2可以防止溢出
            if (target < nums[middle]){
                right = middle - 1; // middle肯定不是了，因此要middle-1
            }
            else if(target > nums[middle]){
                left = middle + 1; //同上
            }
            else if(target == nums[middle])
                return middle;            
        }
        return -1;//在[nums[0], nums[len-1]]之间，但不是已有的数
    }
}
